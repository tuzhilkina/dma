#include <iostream>
#include <array>

// Сортировка всплытием Флойда
// Тужилкина Н.Г.
// БПМ-18-2

class tree {
public:
    tree();
    ~tree() = default;
    void surface(int, int);
    void sort();
    void print();

private:
    std::array<int, 17> data{ 0 };
};

tree::tree() {
    for (auto& it : data)
        it = std::rand() % 100;
}

void tree::print() {
    for (auto& it : data)
        std::cout << it << " ";
    std::cout << "\n";
}

// Преобразует почти упорядоченное дерево в упорядоченноеэ
// упорядоченное дерево - значение в его вершине не меньше, чем значения в дочерних вершинах
// частично упорядоченное дерево - упорядоченность выполняется для каждой из вершин, но не для корня
void tree::surface(int root, int max) {
    // root - корень поддерева
    // max - элемент массива с максимальным индексом, который принадлежит дереву, то есть конец дерева
    int child(-1); // большая из вершин поддерева
    // сохранение значения корня поддерева
    int copy(data[root]);
    // пока мы находимся в пределах поддерева
    while (2 * root <= max) {
        // если левая вершина совпадает с максимальным элементом поддерева
        if (2 * root == max)
            child = 2 * root; // то это нужная вершина
        else
            // выбираем большую вершину. При равенстве выбирается правая
            (data[2 * root] > data[2 * root + 1]) ? (child = 2 * root) : (child = 2 * root + 1);

        // если вершина больше корня
        if (data[child] > copy) {
            // большая вершина становится корнем
            data[root] = data[child];
            root = child;
        }
        // в вершине находится больший элемент
        else break;
    }
    // перенос корня всего поддерева на место, где находилась большая вершина
    data[root] = copy;
}

void tree::sort() {
    int last = data.size() - 1; // номер последнего элемента в массиве
    // идем по "уровням" - от нижнего к верхнему
    // на нижнем уровне поддерево - корень + 2 вершины
    // в корне оказывается большее из 3 чисел
    // на верхних уровнях нет необхомости просматривать все многоуровневое поддерево целиком:
    // большие элементы нижних уровней располагаются в вершинах, исходящих из корня
    // в результате получаем упорядоченное дерево
    for (int i(last / 2); i > 0; --i)
        surface(i, last);

    // рассматриваем дерево, корень которого - 0
    // а конец дерева - последний элемент перед упорядоченной областью
    for (int i(last); i > 0; --i) {
        // в результате образуется упорядоченное дерево
        // в вершине упорядоченного дерева находиться больший элемент
        surface(0, i);
        // больший элемент переносится в конец дерева
        // конец дерева теперь принадлежит упорядоченной области
        // дерево становится частично упорядоченным
        std::swap(data[i], data[0]);
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    std::cout << "Лабораторная работа №6. Сортировка всплытием Флойда\n";
    std::cout << "Тужилкина Н.Г., БПМ-18-2\n";
    std::cout << "\nНеотсортированный массив:\n";
    tree data = tree();
    data.print();
    data.sort();
    std::cout << "\nОтсортированный массив:\n";
    data.print();
}
